<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Dokumentacja projektu na rekrutacje do KN Solvro by Kajetan Plewa
 * Parę moich komentarzy co do projektu. Na przyszłość - powinienem go lepiej rozplanować bo konstrukcja bazy danych(mimo, że ma swoje benefity)
 * mocno skomplikowała kod. Napewno niepotrzebne też są oddzielne GETy do id, gdyż mozna by to bylo rozwiazac przy pomocy filtrowania. Sortowanie też
 * mogło by być o wiele prostsze gdyby zrobić kolumnę array posiadająca składniki, zamiast bawić się w oddzielną tabelę.
 */

import dotenv from 'dotenv';
dotenv.config();
import express, { json, query } from 'express';
const app = express();
import { createConnection } from 'mysql2';

/**
 * Konfiguracja połączenia z bazą danych MySQL z wykorzystaniem dotenv w celu wiekszego bezpieczeństwa - należy stworzyć wlasny plik .env z podanymi zmiennymi srodowiskowymi.
 * @constant
 */
const database = createConnection({
    host:process.env.DB_HOST,
    user:process.env.DB_NAME,
    password:process.env.DB_PASSWORD,
    database: 'solvrorecrutation'
});

/**
 * Połączenie z bazą danych MySQL.
 * @param {Error} err - Błąd, jeśli połączenie się nie powiedzie.
 */
database.connect((err)=>{
    if(err){
        console.error("Nie udalo sie polaczyc z baza danych, " + err);
        console.log(process.env.DB_NAME,process.env.DB_PASSWORD);
        return;
    }
    console.log("Polaczona z baza danych");
})

app.use(json());
export default app;

const PORT = process.env.PORT || '8080';
app.listen(PORT, ()=>console.log('Server is running ' + PORT));

/**
 * Konstruktor zapytania SQL, który dynamicznie buduje zapytanie na podstawie podanych parametrów. Część dotycząca orderu i direction
 * nie jest potrzebna ale zostawiem ją w celu ewentualnych modyfikacji projektu bazy danych na bliższą optymalej
 * @param {string} category - Kategoria koktajli.
 * @param {string} order - Kolumna, według której będzie sortowanie.
 * @param {string} direction - Kierunek sortowania (ASC lub DESC).
 * @param {string} query - Początkowe zapytanie SQL.
 * @param {boolean} WhereExists - Określa, czy istnieje już klauzula WHERE.
 * @returns {string} Skonstruowane zapytanie SQL.
 */
function queryConstructor(category, order, direction, query, WhereExists){
    if(category){
        if(!WhereExists){
            query+=" WHERE category=? ";
        }
        else{
            query+=" AND category=? "
        }
    }
    if(order){
        query+=" ORDER BY "+order;
    }
    if(direction){
        query+=" "+direction;
    }
    return(query);
}

/**
 * Zwraca liczbę koktajli pasujących do zapytania. Wykorzystywana w pętli while GET /cocktails 
 * - przewiduje ile razy musi się ona wykonać, by pokazać wszystkie koktajle - raz jeszcze można by to było ulepszyć poprzez modyfikację bazy danych.
 * (pozbyciu sie tabeli wsipierajacej i dodaniu kolumny ingredients z typem array)
 * @param {string} query - Zapytanie SQL do wykonania.
 * @param {string} category - Kategoria koktajli.
 * @returns {Promise&lt;number>} Liczba koktajli.
 * @throws {Array} W przypadku błędu wykonania zapytania zwraca tablicę z błędem i kodem statusu.
 */
function NumberOfCocktails(query, category){
    return new Promise ((resolve,reject)=>{
        database.query(query, category,(err,result)=>{
            if(err){
                console.error("query is wrong: ",err);
                reject(['query is wrong',"500"]);
                return;
            }
            if(result.length==0){
                console.error("The table is empty");
                reject(['No such cocktails have been created',"404"]);
                return;
            }
            resolve(result.length);
    });
})
}

/**
 * Endpoint GET zwracający listę wszystkich koktajli. Z powodu konstrukcji bazy danych zbiera wszystkie koktajle w arrayu ktory potem jest sortowany.
 * Dało by się to o wiele prościej.
 * @route GET /cocktails
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.get('/cocktails', (req,res)=>{
    const { category, order, direction } = req.query;

(async () => {
    try{
    var konkatenacja=[];
    var i =1;
    var Id = 1;
    var query = 'SELECT * from cocktails '
    if(category||order||direction){
        query = queryConstructor(category,order,direction,query,false);
    }
    const CountCocktails = await NumberOfCocktails(query,category);
    while(i&lt;=CountCocktails){
        query = queryConstructor(category,order,direction,'SELECT * from cocktails WHERE cocktail_id=? ',true);
        if(await doesCocktailExistID(Id,query, category)){
            const cocktailResult = await getCocktailOfId(Id);
            const ingredient_cocktailResult = await getCocktail_IngredientOfId(Id);
            const result = {
                cocktail_id:cocktailResult[0],
                name: cocktailResult[1],
                category: cocktailResult[2],
                instructions: cocktailResult[3],
                ingredients: [ingredient_cocktailResult] 
            }
            konkatenacja.push(result);
            i++;
        }
        Id++;
    }
    konkatenacja=resultSorter(konkatenacja,order,direction);
    res.status(200).send(konkatenacja);}
    catch(error){
        console.error(error[0]);
        res.status(parseInt(error[1])).send(error[0]);
    }
})();
});

/**
 * Funkcja asynchroniczna pobierająca dane o koktajlu o podanym ID.
 * @param {number} Id - ID koktajlu.
 * @returns {Promise&lt;Array>} Tablica zawierająca informacje o koktajlu.
 * @throws {Array} W przypadku błędu zwraca tablicę z błędem i kodem statusu.
 */
function getCocktailOfId(Id){
    return new Promise((resolve,reject)=>{

        database.query('SELECT cocktail_id,name,category,instructions from cocktails WHERE cocktail_id=?',Id ,(err,result)=>{
            if(err){
                console.error("query is wrong: ",err);
                reject(['database error',"500"]);
                return;
            }
            if(result.length==0){
                console.error("Cocktail wasnt found");
                reject(['There isnt any ingredient_cocktail with the requested id',"404"]);
                return;
            }
            console.log(result[0].cocktail_id);
            resolve([result[0].cocktail_id,result[0].name,result[0].category,result[0].instructions]);
            return;
    });
})
}

/**
 * Pobiera listę składników dla koktajlu o podanym ID.
 * @param {number} Id - ID koktajlu.
 * @returns {Promise&lt;Array>} Lista składników z ilością.
 */
function getCocktail_IngredientOfId(Id){
    return new Promise((resolve,reject)=>{
        database.query('SELECT name, ml from cocktails_ingredients WHERE cocktail_id=?',Id ,(err,result)=>{
            if(err){
                console.error("query is wrong: ",err);
                reject(['database error',"500"]);
                return;
            }
            if(result.length==0){
                console.error("ingredient_cocktail wasnt found");
                reject(['There isnt any ingredient_cocktail with the requested id',"404"]);
                return;
            }
            resolve(result);
            return;
    });
})
}

/**
 * Endpoint GET zwracający szczegóły koktajlu na podstawie jego ID.
 * @route GET /cocktails/:id
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.get('/cocktails/:id', (req,res)=>{
    (async () => {
        try{
        const cocktailResult = await getCocktailOfId(req.params.id);
        const ingredient_cocktailResult = await getCocktail_IngredientOfId(req.params.id);
        const result = {
            cocktail_id:cocktailResult[0],
                cocktailname: cocktailResult[1],
                cocktail_category: cocktailResult[2],
                cocktail_instructions: cocktailResult[3],
                ingredients: [ingredient_cocktailResult] 
        }
        console.log(result);
        res.status(200).json(result);
    }catch(error){
        console.error(error[0]);
        res.status(parseInt(error[1])).send(error[0]);
    }
    })();
});

/**
 * Endpoint GET zwracający wszystkie składniki.
 * @route GET /ingredients
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.get('/ingredients', (req,res)=>{
    database.query('SELECT * from ingredients', (err,result)=>{
        if(err){
            console.error("query is wrong: ",err);
            return res.status(500).send("database error");
        }
        if(result.length===0){
            console.error("The ingredients table is empty");
            res.status(404).send('No ingredient has been created');
            return;
        }
        res.status(200).json(result);
    })
    });
   
/**
 * Endpoint GET zwracający szczegóły składnika na podstawie jego ID.
 * @route GET /ingredients/:id
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */    
app.get('/ingredients/:id', (req,res)=>{
        database.query('SELECT * from ingredients WHERE ingredient_id=?',parseInt(req.params.id) ,(err,result)=>{
            if(err){
                console.error("query is wrong: ",err);
                return res.status(500).send("database error");
            }
            if(result.length==0){
                console.error("Ingredient wasnt found");
                res.status(404).send('There isnt any ingredient with the requested id: '+parseInt(req.params.id));
                return;
            }
            res.status(200).json(result);
        })
    });

    /**
 * Przeszukuje tabelę wspierającą składniki koktajlu na podstawie jego ID.
 * @param {number} Id - ID koktajlu.
 * @returns {Promise&lt;Array>} Lista nazw składników.
 * @throws {Array} Błąd, jeśli składnik nie zostanie znaleziony.
 */
function supportingTableIngredientsSearch(Id){
    return new Promise((resolve,reject)=>{
        const query = 'SELECT name from cocktails_ingredients WHERE cocktail_id=?'
        database.query(query,[Id],(err,result)=>{
            if(err){
                reject(["Supporting Table Problem"+query,"500"]);console.error("Supporting Table Problem");
                return;
            }
            if(result.length===0){
                reject(["Not found in cocktails_ingredients table"+query+Id,"404"]);
                return;
            }
            else{
                console.log("Znaleziono w wspierajacej tablicy");
                resolve(result);            }
        })
    });
}

/**
 * Znajduje ilość składnika w magazynie na podstawie jego nazwy.
 * @param {string} name - Nazwa składnika.
 * @returns {Promise&lt;number>} Ilość składnika w magazynie.
 * @throws {Array} Błąd, jeśli składnik nie zostanie znaleziony.
 */
function findIngredientAmount(name){
    return new Promise((resolve,reject)=>{
        
        const query2 = 'SELECT amount from ingredients WHERE name=?';
        database.query(query2,name, (err,result)=>{
            if(err){
                reject(["Database error - findIngredientAmount "+name,"500"]);
                return;
            }
            if(result.length===0){
                reject(["Not found - findIngredientAmount func"+name,"404"]);
                return;
            }
            resolve(result[0].amount);
            return;
        });
   
});
}

/**
 * Wyszukuje składnik według nazwy oraz sprawdza jego dostępność.
 * @param {string} name - Nazwa składnika.
 * @param {number} ml - Ilość składnika w mililitrach.
 * @param {string} type - Typ operacji (cocktails lub cocktails_create).
 * @returns {Promise&lt;Array>} Informacje o składniku lub jego ID.
 * @throws {Array} Błąd, jeśli składnik nie zostanie znaleziony lub brakuje go w wystarczającej ilości.
 */
function ingredientSearching(name,ml,type){
    return new Promise((resolve,reject)=>{
        
            const query2 = 'SELECT name, ingredient_id, amount from ingredients WHERE name=?';
            database.query(query2,name, (err,result)=>{
                if(err){
                    reject(["Database error during the ingredient searching phase "+name,"500"]);
                    return;
                }
                if(result.length===0){
                    reject(["The ingredient required to creata a cocktail was not found "+name,"404"]);
                    return;
                }
                if(result.amount&lt;ml&amp;&amp;type=='cocktails'){
                    reject(["Nie wystarczajaco skladnika "+name,"400"]);
                    return;
                }
                if(type=='cocktails'){
                resolve(["Ingredient "+name+ " is correct",result[0].ingredient_id]);return;}
                else if(type=='cocktails_create'){
                    resolve(result[0].amount);
                    console.log(result[0].amount);
                    return;
                }else{
                    resolve(undefined,'0');
                    return;
                }
            });
       
    });
}

/**
 * Sprawdza, czy składnik o podanej nazwie istnieje.
 * @param {string} name - Nazwa składnika.
 * @returns {Promise&lt;boolean>} True, jeśli składnik istnieje.
 */
function doesIngredientExist(name){
    return new Promise((resolve,reject)=>{
        
            const query2 = 'SELECT name, ingredient_id, amount from ingredients WHERE name=?';
            database.query(query2,name, (err,result)=>{
                if(err){
                    reject(["Database error during the ingredient searching phase "+name,"500"]);
                    return;
                }
                if(result.length===0){
                    resolve(false);
                    return;
                }
                else{
                    resolve(true);
                    return;
                }
            });
       
    });
}

/**
 * Sprawdza, czy koktajl o podanym ID i kategorii istnieje.
 * @param {number} Id - ID koktajlu.
 * @param {string} query - Zapytanie SQL do sprawdzenia.
 * @param {string} category - Kategoria koktajlu.
 * @returns {Promise&lt;boolean>} True, jeśli koktajl istnieje.
 */
function doesCocktailExist(name){
    return new Promise((resolve,reject)=>{
        
        const query2 = 'SELECT name, cocktail_id from cocktails WHERE name=?';
        database.query(query2,name, (err,result)=>{
            if(err){
                reject(["Database error during the cocktails searching phase "+name,"500"]);
                return;
            }
            if(result.length===0){
                resolve(false);
                return;
            }
            resolve(true);
        });
   
});
}

/**
 * Sprawdza, czy koktajl o podanej nazwie istnieje.
 * @param {string} name - Nazwa koktajlu.
 * @returns {Promise&lt;boolean>} True, jeśli koktajl istnieje.
 */
function doesCocktailExistID(Id, query, category){
    return new Promise((resolve,reject)=>{
        let tab = [Id];
        if(category){
            tab.push(category);
        }
        database.query(query,tab, (err,result)=>{
            if(err){
                reject(["Database error during the cocktails searching phase "+Id,"500"]);
                return;
            }
            if(result.length===0){
                resolve(false);
                return;
            }
            resolve(true);
        });
   
});
}

/**
 * Pobiera ID koktajlu na podstawie jego nazwy.
 * @param {string} name - Nazwa koktajlu.
 * @returns {Promise&lt;number>} ID koktajlu.
 */
function cocktailSearching(name){
    return new Promise((resolve,reject)=>{
        
            const query2 = 'SELECT name, cocktail_id from cocktails WHERE name=?';
            database.query(query2,name, (err,result)=>{
                if(err){
                    reject(["Database error during the cocktails searching phase "+name,"500"]);
                    return;
                }
                if(result.length===0){
                    console.error("Couldnt find the cocktail "+name+query2);
                    reject(["Couldnt find the cocktail "+name+query2,"404"]);
                    return;
                }
                resolve(result[0].cocktail_id);
            });
       
    });
}

/**
 * Wstawia nowy koktajl do bazy danych.
 * @param {string} name - Nazwa koktajlu.
 * @param {string} category - Kategoria koktajlu.
 * @param {string} instructions - Instrukcje przygotowania koktajlu.
 * @returns {Promise&lt;Array>} Wynik wstawienia oraz ID nowego koktajlu.
 */
function insertingCocktail(name,category,instructions){
    return new Promise((resolve,reject)=>{
        
        const query = 'INSERT INTO cocktails(name,category,instructions) VALUES (?,?,?)';
        database.query(query,[name,category,instructions],(err,result2)=>{
            if(err){
            if(err.message.includes("Column 'name' cannot be null")){
                reject(["query wrong - name cannot be a null ","400"]);
                return;
            }
            if(err.message.includes("Column 'category' cannot be null")){
                reject(["query wrong - category cannot be a null ","400"]);
                return;
            }
            if(err.message.includes("Column 'instructions' cannot be null")){
                reject(["query wrong - instructions cannot be a null ","400"]);
                return;
            }
        }
            resolve(["Koktajl stworzony",result2.insertId]);
        });
    
    });
}

/**
 * Wstawia dane do pomocniczej tabeli składników koktajlu.
 * @param {number} insertedID - ID nowo utworzonego koktajlu.
 * @param {string} name - Nazwa składnika.
 * @param {number} ml - Ilość składnika w mililitrach.
 * @param {number} ingID - ID składnika.
 * @returns {Promise&lt;string>} Wynik operacji.
 */
function insertingSupportingTable(insertedID,name,ml,ingID){
    return new Promise((resolve,reject)=>{
        database.query('INSERT INTO cocktails_ingredients VALUES(?,?,?,?)',[insertedID,name,ml,ingID],(err,result3)=>{
            if(err){
                reject(['Dodawanie do tabeli pomocniczej nie dziala '+err,'500']);
                return;
            }
            resolve('Prawidlowe dodanie do wspierajacej tabeli');
            // res.status(200).send('Child table filled');
        });
});

}

/**
 * Aktualizuje dane w tabeli na podstawie podanych edycji. Jest przygotowana na składniki i koktajle oraz tablicę wspierająca.
 * @param {string} type - Typ tabeli (cocktails, ingredients, cocktails_ingredients).
 * @param {Array} ArrayOfEdits - Tablica edycji do wykonania.
 * @param {string} ObjectName - Nazwa obiektu do edycji.
 * @param {number} ObjectID - ID obiektu (opcjonalne).
 * @returns {Promise&lt;Array>} Wynik aktualizacji i kod statusu.
 */
function updatingTable(type,ArrayOfEdits, ObjectName, ObjectID){
    var ToBeEdited=[];
    var NamesOfEdits=[]
    for(let y of ArrayOfEdits){
            if(y[1]!=null){
                ToBeEdited.push(y[1]);
                NamesOfEdits.push(y[0]);
            }
    }
    const CountOfEdits = ToBeEdited.length;
    ToBeEdited.push(ObjectName);
    var query;
    var wherestatement;
    if(type.localeCompare('cocktails')===0){
        query ='UPDATE cocktails SET ';
        wherestatement =' WHERE cocktails.name=?';
    }else if(type.localeCompare('ingredients')===0){
        query ='UPDATE ingredients SET ';
        wherestatement =' WHERE ingredients.name=?';
    }else if(type.localeCompare('cocktails_ingredients')===0){
        query ='UPDATE cocktails_ingredients SET ';
        wherestatement =' WHERE cocktails_ingredients.name=? AND cocktails_ingredients.cocktail_id=?';
        ToBeEdited.push(ObjectID);
    }
    for(let i=0;i&lt;CountOfEdits;i++){
        // query+=' cocktails.${NamesOfEdits[i]}=? ';
        query+= NamesOfEdits[i]+' = ? ';
        if(i&lt;CountOfEdits-1){
            query+=" , ";
        }
    }

        query+=wherestatement;

        return new Promise((resolve,reject)=>{
            database.query(query,ToBeEdited,(err,result)=>{
                if(err){
                    reject(["Database error - updating"+err+query+NamesOfEdits+ToBeEdited,"500"]);
                    return;
                }
                if(result.affectedRows===0){
                    reject(["Not found","404"]);
                    return;
                }
                else{
                    resolve(["Successful update+"+query+ToBeEdited+NamesOfEdits,"200"]);
                }
            })
        });
    
}

/**
 * Tworzy nowy koktajl na podstawie danych w żądaniu. Sprawdza dwa przypadki:
 * 1) Gdy dany koktajl już istnieje - wtedy kaze uzytkownikowi zmienic nazwe badz edytowac istniejacy koktajl o tej nazwie
 * 2) Jesli nie istnieje - tworzy nowy koktajl, poprzez najpierw sprawdzenie czy istnieje wystarczajaca ilosc skladnikow
 * jesli istnieja - dodaje koktajl do tablicy cocktails i jego skladniki do tablicy wspierajacej i łączącej ingredients i cocktails - cocktails_ingredients.
 * Na koniec usuwa z ingredients tyle ile zużyto w procesie tworzenia.
 * @route POST /cocktails/create
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.post('/cocktails/create', (req,res)=>{
        const name = req.body.name||null;
        const category = req.body.category||null;
        const ingredients = req.body.ingredients||null;
        const instructions = req.body.instructions||null;
        var insertedID;
        var ingID=[];

        async function createCocktail(){
            try{
                if(await doesCocktailExist(name)){
                    res.status(400).send("Cocktail with this name already exists - try using a different name or use /cocktails/edit/:name to edit the cocktail");
                }else{
                for(const x of ingredients){
                    const searchingResult = await ingredientSearching(x.name,x.ml,'cocktails');
                    console.log(searchingResult[0]);
                    ingID.push(searchingResult[1]);
                }
                const insertingCocktailResult = await insertingCocktail(name,category,instructions);
                console.log(insertingCocktailResult[0]);
                insertedID=insertingCocktailResult[1];
                for(let i=0;i&lt;ingredients.length;i++){
                    const insertingSupportingTableResult = await insertingSupportingTable(insertedID,ingredients[i].name,ingredients[i].ml,ingID[i]);
                    console.log(insertingSupportingTableResult);
                    let ML = await ingredientSearching(ingredients[i].name,0,'cocktails_create');
                    console.log(ML);
                    const ingredientMLEdit = await updatingTable('ingredients',[['amount',ML-ingredients[i].ml]],ingredients[i].name,0);
                    console.log(ingredientMLEdit);
                }
                res.status(201).send("Cocktail sucessfully created");
                console.log("Cocktail successfully created");}
            }
            catch(error){
                console.error(error[0]);
                res.status(parseInt(error[1])).send(error[0]);
            }
        }

        createCocktail();
        
    });

/**
 * Tworzy nowy składnik na podstawie danych w żądaniu. Jesli takowy istnieje to dodaje tylko ilosc.
 * @route POST /ingredients/create
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.post('/ingredients/create', async(req,res)=>{
        const name = req.body.name||null;
        const description = req.body.description||null;
        var alcohol = req.body.alcohol||null;
        const amount = req.body.amount||null;
        const image = req.body.image||null;
        let IngredientExsit = undefined;
        let amountofIngredient=0;

        if(alcohol=="true"||alcohol=="True"){
            alcohol=true;
        }else if(alcohol=="false"||alcohol=="False"){
            alcohol=false;
        }
        try{
        IngredientExsit = await doesIngredientExist(name);
        console.log(IngredientExsit);
        if(!IngredientExsit){
            const query = 'INSERT INTO ingredients(name,description,alcohol,image,amount) VALUES (?,?,?,?,?)';

        database.query(query,[name,description,alcohol, image, amount], (err,result)=>{
            if(err){
            if(err.message.includes("Column 'name' cannot be null")){
                console.error("query wrong - name cannot be a null");
                res.status(400).send("Name cannot be a null");
                return;
            }
            if(err.message.includes("Column 'description' cannot be null")){
                console.error("query wrong - description cannot be a null");
                res.status(400).send("Description cannot be a null");
                return;
            }
            if(err.message.includes("Column 'alcohol' cannot be null")){
                console.error("query wrong - alcohol cannot be a null");
                res.status(400).send("Alcohol cannot be a null");
            }
            return;
        }
            console.log('Ingredient successfuly created');
            res.status(201).send('Ingredient '+name+' was successfully created');
        })
        }else if(IngredientExsit){
            amountofIngredient = await findIngredientAmount(name);
            console.log(amountofIngredient);
            const updateIngredient = await updatingTable('ingredients',[['amount',amount+amountofIngredient]],name,undefined);
            res.status(201).send('Ingredient already exists - it was added to the already existing inventory');
        }
    }
    catch(error){
        console.error(error);
        res.status(parseInt(error[1])).send(error[0]);
    }
    });

    /**
 * Edytuje dane składnika na podstawie jego nazwy.
 * @route PUT /ingredients/edit/:name
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.put('/ingredients/edit/:name', (req,res)=>{
    const name = req.body.name||null;
        const description = req.body.description||null;
        var alcohol = req.body.alcohol||null;
        const amount = req.body.amount||null;
        const image = req.body.image||null;

        if((alcohol=="true")||(alcohol==="True")){
            alcohol=true;
        }else{
            alcohol=false;
        }

        async function updatingIngredient() {
            try{
            const upgradeResult = await updatingTable("ingredients",[['name',name],['description',description],['alcohol',alcohol],['amount',amount],['image',image]],req.params.name,undefined);
            res.status(parseInt(upgradeResult[1])).send(upgradeResult[0]);
            console.log(upgradeResult[0]);
            }catch(error){
                console.error(error[0]);
                res.status(parseInt(error[1])).send(error[0]);
            }
        }

        updatingIngredient();

});

/**
 * Edytuje dane koktajlu na podstawie jego nazwy.
 * @route PUT /cocktails/edit/:name
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.put('/cocktails/edit/:name', (req,res)=>{
        const name = req.body.name||null;
        const category = req.body.category||null;
        const ingredients = req.body.ingredients||null;
        const instructions = req.body.instructions||null;


        async function updatingCocktail(table,tab,ObjectID) {
            try{
            const updateResult = await updatingTable(table,tab,req.params.name,ObjectID);
            console.log('Update Result:', updateResult);
            const SearchResult = await cocktailSearching(name);
            const NamesOfIngredientsTable = await supportingTableIngredientsSearch(SearchResult);
            for(let x of ingredients){
                const ingredient_cocktailResult = await updatingTable('cocktails_ingredients',[['name',x.name],['ml',x.ml]],x.originalname,SearchResult);
                console.log('Update result: '+ingredient_cocktailResult);
            }
            res.status(parseInt(updateResult[1])).send(updateResult[0]);
            }catch(error){
                console.error(error[0]);
                res.status(parseInt(error[1])).send(error[0]);
            }
        }  
        updatingCocktail('cocktails',[["name",name],['category',category],['instructions',instructions]],0);
});

/**
 * Usuwa koktajl na podstawie ID. Najpierw usuwa skladniki polaczone z koktajlem w tablicy wspierajacej.
 * @route DELETE /cocktails/delete/:id
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.delete('/cocktails/delete/:id',(req,res)=>{
    
    (async () => {
    try{
        const cocktail_ingredientDeleteResult = await (()=>{
            return new Promise((resolve,reject)=>{
                let query = 'DELETE FROM cocktails_ingredients WHERE cocktail_id=?';
                database.query(query,[req.params.id],(err,result)=>{
                    if(err){
                        reject(["Database problem - cocktail_ingredients delete "+err,"500"]);
                        return;
                    }
                    if(result.affectedRows===0){
                        reject(["Cocktails_ingredients Not Found - app.Delete","404"]);
                        return;
                    }
                    resolve(["Cocktails_ingredients successfuly deleted","200"]);
                }) 
            })
        })();
        const cocktailDeleteResult = await (()=>{
            return new Promise((resolve,reject)=>{
                let query = 'DELETE FROM cocktails WHERE cocktail_id=?';
            database.query(query,[req.params.id],(err,result)=>{
                if(err){
                    reject(["Database problem - cocktail delete "+err,"500"]);
                    return;
                }
                if(result.length===0){
                    reject(["Cocktail Not Found - app.Delete","404"]);
                    return;
                }
                resolve(["Cocktail successfuly deleted","200"]);
            })
            })
        })();

        res.status(200).send("Delete process completed");
        console.log("Delete Process completed")
    }catch(error){
        res.status(parseInt(error[1])).send(error[0]);
        console.error(error[0]);
    }
})();
});

/**
 * Usuwa składnik na podstawie jego ID.
 * @route DELETE /ingredients/delete/:id
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.delete('/ingredients/delete/:id',(req,res)=>{
    (async () => {
    try{
        const cocktailDeleteResult = await (()=>{
            return new Promise((resolve,reject)=>{
                let query = 'DELETE FROM ingredients WHERE ingredient_id=?';
            database.query(query,[req.params.id],(err,result)=>{
                if(err){
                    reject(["Database problem - ingredient delete "+err,"500"]);
                    return;
                }
                if(result.affectedRows===0){
                    reject(["Cocktail Not Found - app.Delete","404"]);
                    return;
                }
                resolve(["Ingredient successfuly deleted","200"]);
            })
            })
        })();

        res.status(200).send("Delete process completed");
        console.log("Delete Process completed")
    }catch(error){
        res.status(parseInt(error[1])).send(error[0]);
        console.error(error[0]);
    }
})();
});

/**
 * Usuwa wszystkie składniki.
 * @route DELETE /ingredients/deleteAll
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.delete('/ingredients/deleteAll',(req,res)=>{
    (async () => {
    try{
        const cocktailDeleteResult = await (()=>{
            return new Promise((resolve,reject)=>{
                let query = 'Delete From ingredients';
            database.query(query,(err,result)=>{
                if(err){
                    reject(["Database problem - ingredient deleteALL "+err,"500"]);
                    return;
                }
                if(result.affectedRows===0){
                    reject(["No ingredients to delete Not Found - app.Delete"+query,"404"]);
                    return;
                }
                resolve(["Ingredient successfuly deleted","200"]);
            })
            })
        })();

        await (()=>{
            return new Promise((resolve,reject)=>{
                database.query('ALTER TABLE ingredients AUTO_INCREMENT = 1', (err,result)=>{
                    if (err) {
                        console.error("Error resetting auto-increment on ingredients:", err);
                        reject(["Database problem - resetting auto-increment " + err, "500"]);
                        return;
                    }
                    console.log("Auto-increment reset for ingredients");
                    resolve();
                });
            });
        })();

        res.status(200).send("Delete ALL process completed");
        console.log("Delete ALL Process completed")
    }catch(error){
        res.status(parseInt(error[1])).send(error[0]);
        console.error(error[0]);
    }
})();
});

/**
 * Usuwa wszystkie koktajle oraz połączone z nimi składniki - resetuje także id.
 * @route DELETE /cocktails/deleteAll
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.delete('/cocktails/deleteAll',(req,res)=>{
    
    (async () => {
    try{
        const cocktail_ingredientDeleteResult = await (()=>{
            return new Promise((resolve,reject)=>{
                let query = 'DELETE FROM cocktails_ingredients';
                database.query(query,[],(err,result)=>{
                    if(err){
                        reject(["Database problem - cocktail_ingredients deleteALL "+err,"500"]);
                        return;
                    }
                    console.log('supporting table ALL deleted');
                    resolve();
                }) 
            })
        })();
        const cocktailDeleteResult = await (()=>{
            return new Promise((resolve,reject)=>{
            database.query('DELETE FROM cocktails',[],(err,result)=>{
                if(err){
                    reject(["Database problem - cocktail delete "+err,"500"]);
                    return;
                }
                console.log("all cocktails deleted");
                resolve();
            })
            })
        })();
        await (()=>{
            return new Promise((resolve,reject)=>{
                database.query('ALTER TABLE cocktails AUTO_INCREMENT = 1', (err,result)=>{
                    if (err) {
                        console.error("Error resetting auto-increment on cocktails:", err);
                        reject(["Database problem - resetting auto-increment " + err, "500"]);
                        return;
                    }
                    console.log("Auto-increment reset for cocktails");
                    resolve();
                });
            });
        })();
        res.status(200).send("DeleteALL process completed");
        console.log("DeleteALL Process completed")
    }catch(error){
        res.status(parseInt(error[1])).send(error[0]);
        console.error(error[0]);
    }
})();
});

/**
 * Usuwa składnik na podstawie jego nazwy.
 * @route DELETE /ingredients/deletename/:name
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 */
app.delete('/ingredients/deletename/:name',(req,res)=>{
    (async () => {
    try{
        const cocktailDeleteResult = await (()=>{
            return new Promise((resolve,reject)=>{
                let query = 'DELETE FROM ingredients WHERE name=?';
            database.query(query,[req.params.name],(err,result)=>{
                if(err){
                    reject(["Database problem - ingredient delete "+err,"500"]);
                    return;
                }
                if(result.length===0){
                    reject(["Ingredient Not Found - app.Delete","404"]);
                    return;
                }
                resolve(["Ingredient successfuly deleted","200"]);
            })
            })
        })();

        res.status(200).send("Delete process completed");
        console.log("Delete Process completed")
    }catch(error){
        res.status(parseInt(error[1])).send(error[0]);
        console.error(error[0]);
    }
})();
});

/**
 * Funkcja asynchroniczna obsługująca usuwanie koktajli po nazwie.
 * @param {Request} req - Obiekt żądania HTTP.
 * @param {Response} res - Obiekt odpowiedzi HTTP.
 * @route DELETE /cocktails/deletename/:name
 */
app.delete('/cocktails/deletename/:name',(req,res)=>{
    
    (async () => {
    try{
        const cocktail_ingredientDeleteResult = await (()=>{
            return new Promise(async(resolve,reject)=>{
                const ID = await cocktailSearching(req.params.name);
                console.log(ID);
                let query = 'DELETE FROM cocktails_ingredients WHERE cocktail_id=?';
                database.query(query,[ID],(err,result)=>{
                    if(err){
                        reject(["Database problem - cocktail_ingredients delete "+err+query+ID,"500"]);
                        return;
                    }
                    if(result.affectedRows===0){
                        reject(["Cocktails_ingredients Not Found - app.Delete","404"]);
                        return;
                    }
                    resolve(["Cocktails_ingredients successfuly deleted","200"]);
                }) 
            })
        })();
        const cocktailDeleteResult = await (()=>{
            return new Promise((resolve,reject)=>{
                let query = 'DELETE FROM cocktails WHERE name=?';
            database.query(query,[req.params.name],(err,result)=>{
                if(err){
                    reject(["Database problem - cocktail delete "+err,"500"]);
                    return;
                }
                if(result.affectedRows===0){
                    reject(["Cocktail Not Found - app.Delete","404"]);
                    return;
                }
                resolve(["Cocktail successfuly deleted","200"]);
            })
            })
        })();

        res.status(200).send("Delete process completed");
        console.log("Delete Process completed")
    }catch(error){
        res.status(parseInt(error[1])).send(error[0]);
        console.error(error[0]);
    }
})();
});

/**
 * Sortuje wyniki koktajli w zależności od kolumny i kierunku. Słuzy do obsluzenia GET /cocktails, odpowiada za order i direction
 * @param {Array} tab - Tablica obiektów do posortowania.
 * @param {string} order - Kolumna do sortowania.
 * @param {string} direction - Kierunek sortowania (ASC lub DESC).
 * @returns {Array} Posortowana tablica.
 */
function resultSorter(tab,order,direction){
if(order=='instructions'||order=='category'){
    tab = resultstringSorter(tab,order,direction);
}else if(order=='cocktail_id'){
    tab = resultintegerSorter(tab,order,direction);
}
if(direction=='DESC'||direction=='desc'){
    tab.reverse();
}
return tab;
}

/**
 * Sortuje tablicę wyników tekstowo na podstawie kolumny.
 * @param {Array} tab - Tablica do posortowania.
 * @param {string} order - Kolumna do sortowania.
 * @returns {Array} Posortowana tablica.
 */
function resultstringSorter(tab,order){
    tab.sort((a,b)=>{
        const aName = a[order].toUpperCase();
        const bName = b[order].toUpperCase();
        if(aName>bName){
            return 1;
        }
        if(bName>aName){
            return -1;
        }
        return 0;
    });
    return tab;
}

/**
 * Sortuje tablicę wyników liczbowo na podstawie kolumny.
 * @param {Array} tab - Tablica do posortowania.
 * @param {string} order - Kolumna do sortowania.
 * @returns {Array} Posortowana tablica.
 */
function resultintegerSorter(tab,order){
    tab.sort((a,b)=>{
        return (a[order]-b[order]);
    });
    return tab;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#NumberOfCocktails">NumberOfCocktails</a></li><li><a href="global.html#cocktailSearching">cocktailSearching</a></li><li><a href="global.html#database">database</a></li><li><a href="global.html#doesCocktailExist">doesCocktailExist</a></li><li><a href="global.html#doesCocktailExistID">doesCocktailExistID</a></li><li><a href="global.html#doesIngredientExist">doesIngredientExist</a></li><li><a href="global.html#findIngredientAmount">findIngredientAmount</a></li><li><a href="global.html#getCocktailOfId">getCocktailOfId</a></li><li><a href="global.html#getCocktail_IngredientOfId">getCocktail_IngredientOfId</a></li><li><a href="global.html#ingredientSearching">ingredientSearching</a></li><li><a href="global.html#insertingCocktail">insertingCocktail</a></li><li><a href="global.html#insertingSupportingTable">insertingSupportingTable</a></li><li><a href="global.html#queryConstructor">queryConstructor</a></li><li><a href="global.html#resultSorter">resultSorter</a></li><li><a href="global.html#resultintegerSorter">resultintegerSorter</a></li><li><a href="global.html#resultstringSorter">resultstringSorter</a></li><li><a href="global.html#supportingTableIngredientsSearch">supportingTableIngredientsSearch</a></li><li><a href="global.html#updatingTable">updatingTable</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Oct 30 2024 22:37:12 GMT+0100 (czas środkowoeuropejski standardowy)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
